version: "3"

services:
  database:
    build:
      context: ./database
      dockerfile: database.Dockerfile
      args:
        - POSTGRES_USER=${POSTGRES_USER}
        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"

  backend:
    depends_on:
      - database
    build:
      context: ./backend
      dockerfile: backend.Dockerfile
      args:
        - DB_CONNECTION_STRING=${DB_CONNECTION_STRING}
        - DB_SSL=${DB_SSL}
    ports:
      - "4000:4000"

  frontend:
    depends_on:
      - database
      - backend
    build:
      context: ./frontend
      dockerfile: frontend.Dockerfile
      args:
        - VITE_API_URL=${VITE_API_URL}
    volumes:
      - frontend-dist:/frontend/dist

  nginx:
    depends_on:
      - frontend
    build:
      context: .
      dockerfile: nginx.Dockerfile
    volumes:
      - frontend-dist:/usr/share/nginx/html
    ports:
      - "80:80"

# Define the Named Volume "frontend-dist"
volumes:
  frontend-dist:
#
#
# Docker Compose Command to run everything (database, backend, frontend)

# -d runs the contains in detached mode
# without -e it automatically reads the .env file for the environment variables because of the ${} syntax above

# docker-compose up -d

# -e pass environment variables

# docker-compose up -d -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=password -e DB_CONNECTION_STRING="postgres://postgres:password@localhost/cloudtracker" -e DB_SSL=true

# --build forces it to rebuild the images

# docker-compose up -d --build
